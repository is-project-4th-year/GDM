"""
Report Model for GDM Risk Assessment Reports - Fixed for Existing Relationships
"""
import uuid
from datetime import datetime
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Boolean, UniqueConstraint
from sqlalchemy.orm import relationship
from app import db

class Report(db.Model):
    """Model for storing report metadata and PDF paths."""
    
    __tablename__ = 'reports'
    
    id = Column(Integer, primary_key=True)
    uuid = Column(String(36), nullable=False, default=lambda: str(uuid.uuid4()))
    
    # Relationships
    patient_id = Column(Integer, ForeignKey('patients.id'), nullable=False)
    risk_assessment_id = Column(Integer, ForeignKey('risk_assessments.id'), nullable=False)
    generated_by = Column(Integer, ForeignKey('users.id'), nullable=False)
    
    # Report details
    report_type = Column(String(50), nullable=False, default='risk_assessment')  # Future: different report types
    title = Column(String(200), nullable=False)
    summary_text = Column(Text)
    
    # File storage
    pdf_filename = Column(String(255))  # Stored filename
    pdf_path = Column(String(500))      # Full path to PDF file
    file_size = Column(Integer)         # File size in bytes
    
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Metadata
    generated_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    is_active = Column(Boolean, nullable=False, default=True)
    
    # ðŸ”¹ UPDATED: hook into RiskAssessment.reports via back_populates
    risk_assessment = relationship(
        'RiskAssessment',
        back_populates='reports',
        foreign_keys=[risk_assessment_id]
    )
    generator = relationship('User', foreign_keys=[generated_by])
    
    def __repr__(self):
        return f'<Report {self.uuid}: {self.title}>'
    
    @property
    def formatted_file_size(self):
        """Return human-readable file size."""
        if not self.file_size:
            return "Unknown"
        
        size = self.file_size
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} TB"
    
    @property
    def download_filename(self):
        """Generate user-friendly download filename."""
        patient_name = f"{self.patient.first_name}_{self.patient.last_name}"
        date_str = self.generated_at.strftime("%Y%m%d")
        return f"GDM_Risk_Report_{patient_name}_{date_str}.pdf"
    
    @classmethod
    def create_report(cls, patient_id, risk_assessment_id, generated_by, title, summary_text=None):
        """Create a new report record."""
        report = cls(
            patient_id=patient_id,
            risk_assessment_id=risk_assessment_id,
            generated_by=generated_by,
            title=title,
            summary_text=summary_text
        )
        return report
    
    @classmethod
    def get_reports_for_patient(cls, patient_id, limit=None):
        """Get all reports for a specific patient."""
        query = cls.query.filter_by(patient_id=patient_id, is_active=True).order_by(cls.generated_at.desc())
        if limit:
            query = query.limit(limit)
        return query.all()
    
    @classmethod
    def get_reports_by_user(cls, user_id, limit=None):
        """Get all reports generated by a specific user."""
        query = cls.query.filter_by(generated_by=user_id, is_active=True).order_by(cls.generated_at.desc())
        if limit:
            query = query.limit(limit)
        return query.all()
    
    @classmethod
    def get_recent_reports(cls, limit=10):
        """Get recent reports across all patients."""
        return cls.query.filter_by(is_active=True).order_by(cls.generated_at.desc()).limit(limit).all()
    
    def soft_delete(self):
        """Soft delete the report (mark as inactive)."""
        self.is_active = False
        db.session.commit()
        
    def to_dict(self):
        """Convert report to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'uuid': self.uuid,
            'patient_name': f"{self.patient.first_name} {self.patient.last_name}",
            'title': self.title,
            'generated_at': self.generated_at.isoformat(),
            'file_size': self.formatted_file_size,
            'generator': self.generator.name,
            'download_filename': self.download_filename
        }